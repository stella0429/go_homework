【week09作业】

1.总结几种 socket 粘包的解包方式：fix length/delimiter based/length field based frame decoder。尝试举例其应用。
2.实现一个从 socket connection 中解码出 goim 协议的解码器。

解答：

题目一：
1）粘包和半包产生概念：
    a.粘包：指当发送两条消息时，比如发送了 ABC 和 DEF，但另一端接收到的却是 ABCD，像这种一次性读取了两条数据的情况就叫做粘包（正常情况应该是一条一条读取的）；
    b.半包：指当发送的消息是 ABC 时，另一端却接收到的是 AB 和 C 两条信息，像这种情况就叫做半包。
    c.产生原因：这是因为 TCP 是面向连接的传输协议，TCP 传输的数据是以流的形式，而流数据是没有明确的开始结尾边界，所以 TCP 也没办法判断哪一段流属于一个消息。
2）粘包的主要原因：
    a.发送方每次写入数据 < 套接字（Socket）缓冲区大小；
    b.接收方读取套接字（Socket）缓冲区数据不够及时。
3）半包的主要原因：
    a.发送方每次写入数据 > 套接字（Socket）缓冲区大小；
    b.发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包。
4）缓冲区概念：
    a.缓冲区又称为缓存，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区。
    b.缓冲区的优势以文件流的写入为例，如果我们不使用缓冲区，那么每次写操作 CPU 都会和低速存储设备也就是磁盘进行交互，那么整个写入文件的速度就会受制于低速的存储设备（磁盘）。但如果使用缓冲区的话，每次写操作会先将数据保存在高速缓冲区内存上，当缓冲区的数据到达某个阈值之后，再将文件一次性写入到磁盘上。因为内存的写入速度远远大于磁盘的写入速度，所以当有了缓冲区之后，文件的写入速度就被大大提升了。
5）粘包和半包模拟代码实现：
    见同目录下/project/cmd/stickybag下代码（包括客户端和服务器端代码）
5)socket粘包的解包方式总结：
    a.fix length:发送方和接收方规定固定大小的缓冲区，也就是发送和接收都使用固定大小的[]byte数组长度，当字符长度不够时使用空字符弥补；
        ——这种方式的问题在于应用层不能发送超过指定大小的数据，所以使用这种方式的前提知道了消息大小会在哪个范围之内，如果不能确定消息的大小范围不太适合用这种方式，这样会导致大的消息发出去会有问题，小的消息又需要大量的数据填充，不划算。
    b.delimiter based：特殊字符结尾，按行读取.
        ——以特殊字符结尾就可以知道流的边界了，因此也可以用来解决粘包和半包的问题。这种方式的问题在于发送的消息内容里面本身就包含用于切分消息的特殊符号，所以在定义消息切分符时候尽量用特殊的符号组合。
    c.length field based frame decoder:封装请求协议，将请求的数据封装为两部分：数据头+数据正文，在数据头中存储数据正文的大小，当读取的数据小于数据头中的大小时，继续读取数据，直到读取的数据长度等于数据头中的长度时才停止。
        ——虽然这种方式可以拿到数据的边界，也不会导致粘包和半包的问题，但这种实现方式的编码成本较大也不够优雅。


题目二：
1）见同目录下/project/cmd/unpack下代码（包括客户端和服务器端代码）
